# 

如果是多继承，比如class A（B,C）
如果B和C中有相同的变量和方法则在A调用这些属性或方法时候，优先规则为从左往右！（也就是优先采用B的属性和方法）

父类的私有属性和方法，在子类中不能直接调用，需要通过父类的公共方法调用

**#当需要在子类中调用父类属性或方法时怎么解决**

好的，这是一个非常核心的面向对象编程问题。在 Python 中，这个问题的答案是： 你不能、也不应该直接调用 。但这背后有更深的机制和“变通”的方法，理解它们很重要。

简而言之，Python 的“私有”属性和方法（以双下划线 __ 开头）被设计为 只能在定义它们的类内部访问 ，子类也无法直接访问。这是为了防止子类无意中覆盖或破坏父类的内部实现，是一种强封装的体现。

### 1. 为什么不能直接调用？—— 名字改编 (Name Mangling)
当你定义一个以双下划线开头的属性或方法时，比如 __my_secret ，Python 解释器会自动在后台对这个名字进行“改编”或“重整”。

它会把名字变成： _ClassName__variableName

示例：

- 在 class Parent 中， __secret_attr 会变成 _Parent__secret_attr 。
- 在 class Child 中， __secret_attr 会变成 _Child__secret_attr 。
因为子类和父类中同名的私有变量被改成了 完全不同 的名字，所以子类自然就访问不到父类的那个私有成员了。

### 2. “强行”调用的方法 (不推荐)
虽然不推荐，但理解了名字改编的原理后，你就知道了如何“强行”访问。你只需要使用那个被改编后的名字即可。

示例代码：
```
class Parent:
    def __init__(self):
        self.__private_attr = "这是父类的私有属性"

    def __private_method(self):
        print("正在调用父类的私有方法")

class Child(Parent):
    def __init__(self):
        super().__init__()
        # 错误的方式：直接调用，会引发 AttributeError
        # print(self.__private_attr) 
        # self.__private_method()

    def call_parent_private_stuff(self):
        print("尝试在子类中调用父类的私有成员...")
        
        # 正确但“不推荐”的方式：使用名字改编后的名称
        print(self._Parent__private_attr)
        self._Parent__private_method()

# --- 测试 ---
child_obj = Child()
child_obj.call_parent_private_stuff()
```
运行结果
```
尝试在子类中调用父类的私有成员...
这是父类的私有属性
正在调用父类的私有方法
```

为什么强烈不推荐这样做？

- 破坏封装 ：这违背了设置私有成员的初衷。父类的作者可能在未来修改这个私有成员，而你的代码因为直接依赖了这个内部实现，将会崩溃。
- 代码脆弱 ：如果父类的类名改变了（比如从 Parent 改为 BaseParent ），那么改编后的名字也会变（ _BaseParent__private_attr ），所有强行调用的子类代码都需要手动修改。
### 3. 正确的“Pythonic”方式是什么？
如果你发现自己需要在子类中访问父类的某个东西，通常意味着你的设计可以改进。以下是两种更优雅、更符合 Python 风格的解决方案：
 **方案一：使用“受保护”的成员 (单下划线 _ )**
这是一种 约定 ，而不是语法强制。以单个下划线 _ 开头的成员被认为是“受保护的”(protected)。

- 含义 ：它告诉其他程序员：“这是一个内部属性/方法，不要在类的外部直接使用它。但是，如果你是这个类的 子类 ，那么你可以根据需要访问或重写它。”
- 行为 ：单下划线开头的成员 不会 被名字改编，因此子类可以 直接访问 。
示例代码 (推荐的方式):
```
class Parent:
    def __init__(self):
        # 使用单下划线，表示这是一个受保护的属性
        self._protected_attr = "这是父类的受保护属性"

    def _protected_method(self):
        print("正在调用父类的受-保护方法")

class Child(Parent):
    def access_protected(self):
        # 子类可以直接访问父类的受保护成员
        print(self._protected_attr)
        self._protected_method()

# --- 测试 ---
child_obj = Child()
child_obj.access_protected()
```
运行结果
```
这是父类的受保护属性
正在调用父类的受保护方法
```
**方案二：在父类中提供公共的接口方法**
如果父类不希望子类直接接触某个属性，但又想提供它的某些信息，可以在父类中定义一个公共方法（getter）来暴露它。
```
class Parent:
    def __init__(self):
        self.__private_attr = "这是父类的私有属性"

    # 提供一个公共方法来间接访问私有属性
    def get_private_attr(self):
        return self.__private_attr

class Child(Parent):
    def access_via_public_method(self):
        # 通过父类提供的公共接口来获取信息
        data = self.get_private_attr()
        print(f"通过父类的公共方法得到的数据: {data}")

# --- 测试 ---
child_obj = Child()
child_obj.access_via_public_method()
```

![输入图片说明](/imgs/2025-12-11/3fvN5H4qEHCMewfB.png)

<!--stackedit_data:
eyJoaXN0b3J5IjpbNjg1MjY5NTE0XX0=
-->